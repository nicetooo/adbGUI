/**
 * Gaze Plugin API Type Definitions
 * 
 * This file provides TypeScript type definitions for writing Gaze plugins.
 * It includes all available types, interfaces, and helper functions.
 */

// ============ Event Types ============

/**
 * Event source types
 */
declare type EventSource =
  | "network"
  | "logcat"
  | "app"
  | "device"
  | "touch"
  | "workflow"
  | "ui"
  | "perf"
  | "assertion"
  | "plugin"
  | "system";

/**
 * Event category types
 */
declare type EventCategory =
  | "network"
  | "log"
  | "state"
  | "action"
  | "performance"
  | "assertion"
  | "plugin"
  | "system";

/**
 * Event level types
 */
declare type EventLevel = "verbose" | "debug" | "info" | "warn" | "error" | "fatal";

/**
 * Unified event structure
 */
declare interface UnifiedEvent {
  id: string;
  deviceId: string;
  timestamp: number;
  source: EventSource;
  category: EventCategory;
  type: string;
  level: EventLevel;
  title: string;
  data: any;
  tags?: string[];
  metadata?: Record<string, any>;
  parentEventId?: string;
  generatedByPlugin?: string;
}

// ============ Plugin Metadata ============

/**
 * Plugin event filters
 */
declare interface PluginFilters {
  /**
   * Filter by event sources
   * @example ["network", "logcat"]
   */
  sources?: EventSource[];

  /**
   * Filter by event types
   * @example ["http_request", "http_response"]
   */
  types?: string[];

  /**
   * Filter by event levels
   * @example ["error", "warn"]
   */
  levels?: EventLevel[];

  /**
   * URL pattern with wildcard support
   * @example "*/api/track*"
   */
  urlPattern?: string;

  /**
   * Title regex pattern
   * @example "error|exception"
   */
  titleMatch?: string;
}

/**
 * Plugin metadata
 */
declare interface PluginMetadata {
  /**
   * Unique plugin identifier
   * @example "tracking-validator"
   */
  id: string;

  /**
   * Display name
   * @example "Tracking Parameter Validator"
   */
  name: string;

  /**
   * Semantic version
   * @example "1.0.0"
   */
  version: string;

  /**
   * Plugin author
   * @example "Gaze Team"
   */
  author?: string;

  /**
   * Plugin description
   */
  description?: string;

  /**
   * Event filters to reduce unnecessary executions
   */
  filters?: PluginFilters;

  /**
   * Plugin configuration (user-defined)
   */
  config?: Record<string, any>;
}

// ============ Plugin Context ============

/**
 * Plugin execution context
 */
declare interface PluginContext {
  /**
   * Plugin configuration from database (set in form's config field)
   * @example const threshold = context.config.slowThresholdMs || 2000;
   */
  config: Record<string, any>;

  /**
   * Plugin persistent state (survives across events)
   * @example context.state.counter = (context.state.counter || 0) + 1;
   */
  state: Record<string, any>;

  /**
   * Log a message (visible in plugin logs)
   * @param message - Message to log
   */
  log(message: string): void;

  /**
   * Emit a derived event (shorthand for adding to derivedEvents)
   * @param type - Event type
   * @param title - Event title
   * @param data - Event data
   * @example context.emit("alert", "High CPU usage", { cpu: 95 });
   */
  emit(type: string, title: string, data?: any): void;

  /**
   * Extract value from JSON using path
   * @param json - JSON object or string
   * @param path - JSON path (e.g., "user.id")
   * @returns Extracted value or undefined
   * @example const userId = context.jsonPath(event.data, "user.id");
   */
  jsonPath(json: any, path: string): any;

  /**
   * Match URL against wildcard pattern
   * @param url - URL to match
   * @param pattern - Wildcard pattern (e.g., "*/api/users*")
   * @returns true if URL matches pattern
   * @example if (context.matchURL(data.url, "*/api/track*")) { ... }
   */
  matchURL(url: string, pattern: string): boolean;
}

// ============ Plugin Result ============

/**
 * Derived event to be generated by plugin
 */
declare interface DerivedEvent {
  /**
   * Event source (usually "plugin")
   */
  source: EventSource;

  /**
   * Event category (usually "plugin")
   */
  category: EventCategory;

  /**
   * Event type (custom, e.g., "tracking_validation_failed")
   */
  type: string;

  /**
   * Event level
   */
  level: EventLevel;

  /**
   * Event title
   */
  title: string;

  /**
   * Event data (will be JSON serialized)
   */
  data: any;

  /**
   * Tags to add to the derived event
   */
  tags?: string[];

  /**
   * Metadata to add to the derived event
   */
  metadata?: Record<string, any>;
}

/**
 * Plugin execution result
 */
declare interface PluginResult {
  /**
   * Derived events to generate
   */
  derivedEvents: DerivedEvent[];

  /**
   * Tags to add to the original event
   */
  tags?: string[];

  /**
   * Metadata to add to the original event
   */
  metadata?: Record<string, any>;
}

// ============ Helper Functions ============

/**
 * Match URL against wildcard pattern
 * @param url - URL to match
 * @param pattern - Wildcard pattern (e.g., "*/api/users*")
 * @returns true if URL matches pattern
 * 
 * @example
 * matchURL("https://api.example.com/users/123", "*/users/*") // true
 * matchURL("https://example.com/home", "*/api/*") // false
 */
declare function matchURL(url: string, pattern: string): boolean;

/**
 * Extract value from JSON using path
 * @param data - JSON data (object or string)
 * @param path - JSON path (e.g., "user.id")
 * @returns Extracted value or undefined
 * 
 * @example
 * jsonPath({ user: { id: 123 } }, "user.id") // 123
 * jsonPath('{"user":{"name":"John"}}', "user.name") // "John"
 */
declare function jsonPath(data: any, path: string): any;

/**
 * Match string against regex pattern and return capture groups
 * @param pattern - Regex pattern
 * @param text - String to match against
 * @returns Array of matches (index 0 = full match, 1+ = capture groups), or null if no match
 * 
 * @example
 * matchRegex("user_(\\d+)", "user_123") // ["user_123", "123"]
 * matchRegex("user_\\d+", "admin") // null
 */
declare function matchRegex(pattern: string, text: string): string[] | null;

/**
 * Format timestamp to human-readable string
 * @param timestamp - Unix timestamp in milliseconds
 * @returns Formatted time string
 * 
 * @example
 * formatTime(Date.now()) // "2026-02-05 18:30:45"
 */
declare function formatTime(timestamp: number): string;

/**
 * Set plugin state (persisted across events)
 * @param key - State key
 * @param value - State value (will be JSON serialized)
 * 
 * @example
 * setState("count", 10)
 * setState("lastUser", { id: 123, name: "John" })
 */
declare function setState(key: string, value: any): void;

/**
 * Get plugin state
 * @param key - State key
 * @returns State value or undefined
 * 
 * @example
 * const count = getState("count") || 0
 * const user = getState("lastUser")
 */
declare function getState(key: string): any;

// ============ Plugin Definition ============

/**
 * Plugin script definition (user code)
 * 
 * ⚠️ IMPORTANT: This type represents the plugin object in your CODE, not the
 * complete plugin data model. Plugin metadata (id, name, version, filters, config) 
 * is managed by the plugin form (Basic Info & Filters tabs), NOT in the code.
 * 
 * Your code should only define the event processing logic (onEvent, onInit, onDestroy).
 * Including metadata in code is optional and will be ignored at runtime.
 * 
 * @note This is different from the Plugin type in pluginStore.ts, which represents
 * the complete plugin data model (including metadata, sourceCode, language, etc.)
 */
declare interface Plugin {
  /**
   * Plugin metadata (OPTIONAL - managed by form, ignored if present in code)
   * @deprecated Use the plugin form to configure metadata instead
   */
  metadata?: PluginMetadata;

  /**
   * Optional initialization function (called once when plugin loads)
   * @param context - Plugin context
   */
  onInit?(context: PluginContext): void;

  /**
   * Event handler (called for each matching event)
   * @param event - Unified event
   * @param context - Plugin context
   * @returns Plugin result with derived events and tags
   */
  onEvent(event: UnifiedEvent, context: PluginContext): PluginResult;

  /**
   * Optional cleanup function (called when plugin unloads)
   * @param context - Plugin context
   */
  onDestroy?(context: PluginContext): void;
}

/**
 * Declare plugin constant - this is the main export of your plugin
 * 
 * Plugin metadata is configured in the form (Basic Info & Filters tabs).
 * Your code should focus on event processing logic only.
 * 
 * @example
 * // Plugin metadata is managed by the form (Basic Info & Filters tabs)
 * // This code only defines the event processing logic
 * 
 * const plugin: Plugin = {
 *   onEvent: (event, context) => {
 *     // Access plugin configuration from context
 *     const config = context.config || {};
 *     
 *     context.log("Processing: " + event.id);
 *     
 *     return { 
 *       derivedEvents: [],
 *       tags: [],
 *       metadata: {}
 *     };
 *   }
 * };
 */
declare const plugin: Plugin;
